size = 5,
stroke = 2) +
labs(title = '2D Ackley function',
fill = 'Z')
# Highlight selected to breed
current_pop$breeder <- selectBreeders(pop = current_pop,
pop_size = pop_size,
breed_prop = breed_prop)
# Plot initial population on heatmap, with breeders highlighted
ggplot() +
geom_contour_filled(data = dat,
aes(x = x,
y = y,
z = z),
bins = 20) +
geom_point(data = current_pop,
aes(x = x,
y = y,
colour = as.factor(breeder)),
shape = 2,
size = 5,
stroke = 2) +
labs(title = '2D Ackley function',
fill = 'Z',
colour = 'Selected')
# Highlight reproduction
current_pop <- reproduce(current_pop = current_pop)
# Plot current population on heatmap, with new born highlighted
ggplot() +
geom_contour_filled(data = dat,
aes(x = x,
y = y,
z = z),
bins = 20) +
geom_point(data = current_pop,
aes(x = x,
y = y,
colour = as.factor(gen)),
shape = 2,
size = 5,
stroke = 2) +
labs(title = '2D Ackley function',
fill = 'Z',
colour = 'Generation')
current_pop
# filter to newest born
pop <- current_pop[current_pop$gen == max(current_pop$gen),]
pop
# roll dice to determine whether each new born mutates
sample(x = c(0,1), size = nrow(pop), replace = T)
# roll dice to determine whether each new born mutates
sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
mut_chance <- 0.1
# roll dice to determine whether each new born mutates
sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
# roll dice to determine whether each new born mutates
sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
# roll dice to determine whether each new born mutates
sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
# roll dice to determine whether each new born mutates
sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
# roll dice to determine whether each new born mutates
pop$mutate <- sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
pop
any(pop$mutate)
class(pop$mutate)
# roll dice to determine whether each new born mutates
pop$mutate <- sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
pop$mutate
any(pop$mutate)
pop$mutate
pop$mutate == 1
length(pop$mutate == 1)
sum(pop$mutate == 1)
sample(x = c(0,1),
size = sum(pop$mutate == 1),
replace = T)
sample(x = c(0,1),
size = sum(pop$mutate == 1),
replace = T)
rnorm(1, mean = 0, sd = 0.1)
rnorm(1, mean = 0, sd = 0.1)
rnorm(1, mean = 0, sd = 0.1)
rnorm(1, mean = 0, sd = 0.1)
rnorm(1, mean = 0, sd = 0.1)
rnorm(1, mean = 0, sd = 0.1)
rnorm(1, mean = 0, sd = 0.1)
rnorm(1, mean = 0, sd = 0.1)
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
A <- sample(x = c(0,1),
size = sum(pop$mutate == 1),
replace = T)
A
mut_chance <- 1
# filter to newest born
pop <- current_pop[current_pop$gen == max(current_pop$gen),]
# roll dice to determine whether each new born mutates
pop$mutate <- sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
pop$mutate
if (any(pop$mutate)){
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
A <- sample(x = c(0,1),
size = sum(pop$mutate == 1),
replace = T)
x_changes <-
y_changes <-
}
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
A <- sample(x = c(0,1),
size = sum(pop$mutate == 1),
replace = T)
A
B <- rnorm(n = length(A), mean = 0, sd = 0.1)
B
pop
pop <- pop[A,]
P
pop
A
# filter to newest born
pop <- current_pop[current_pop$gen == max(current_pop$gen),]
# roll dice to determine whether each new born mutates
pop$mutate <- sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
pop
pop <- pop[pop$mutate == 1,]
pop
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
change_x <- sample(x = c(0,1),
size = sum(pop$mutate == 1),
replace = T)
change_x
change_y <- -1*(change_x - 1)
change_y
change_pc <- rnorm(n = length(A), mean = 0, sd = 0.1)
change_pc
pop[change_x,]
pop[change_x,]$x
current_pop
max(current_pop$gen)
# filter to newest born
pop <- current_pop[current_pop$gen == max(current_pop$gen),]
pop
# roll dice to determine whether each new born mutates
pop$mutate <- sample(x = c(0,1),
size = nrow(pop),
replace = T,
prob = c(1-mut_chance, mut_chance))
pop
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
change_x <- sample(x = c(0,1),
size = sum(pop$mutate == 1),
replace = T)
change_y <- -1*(change_x - 1)
change_pc <- rnorm(n = length(A), mean = 0, sd = 0.1)
change_x
change_y
change_pc
pop <- pop[pop$mutate == 1,]
pop
pop[change_x,]$x
pop
pop[change_x,]
pop
pop[c(0,0,0,1,1,1)]
pop[c(0,0,0,1,1,1),]
pop[c(0,1,0,1,1,1),]
pop[change_x]
pop[change_x,]
pop[as.logical(change_x),]
as.logical(change_x)
pop[as.logical(change_x),]$x
pop[as.logical(change_x),]$x
change_pc
change_pc[as.logical(change_x)]
(pop[as.logical(change_x),]$x
* change_pc[as.logical(change_x)])
change_pc[as.logical(change_x)]
pop[as.logical(change_x),]$x
change_pc[as.logical(change_x)]
change_pc[as.logical(change_x)][1]
pop[as.logical(change_x),]$x[1]
pop[as.logical(change_x),]$x[1]*change_pc[as.logical(change_x)][1]
(pop[as.logical(change_x),]$x
* (1 + change_pc[as.logical(change_x)]))
pop
current_pop
max(current_pop$gen)
current_pop$gen == max(current_pop$gen)
current_pop[current_pop$gen == max(current_pop$gen),]
nrow(current_pop[current_pop$gen == max(current_pop$gen),])
current_pop
# roll dice to determine whether each new born mutates
current_pop$mutate <- c(rep(0,pop_size),
sample(x = c(0,1),
size = nrow(current_pop[current_pop$gen == max(current_pop$gen),]),
replace = T,
prob = c(1-mut_chance, mut_chance)))
current_pop
if (any(pop$mutate)){
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
change_x <- sample(x = c(0,1),
size = sum(pop$mutate == 1),
replace = T)
change_y <- -1*(change_x - 1)
# Determine the amount each changes by.
# normal distribution mean 0, std = 0.2
change_pc <- rnorm(n = length(A), mean = 0, sd = 0.2)
pop <- pop[pop$mutate == 1,]
# Apply changes to x and y
pop[as.logical(change_x),]$x <- (pop[as.logical(change_x),]$x
* (1 + change_pc[as.logical(change_x)]))
pop[as.logical(change_y),]$y <- (pop[as.logical(change_y),]$y
* (1 + change_pc[as.logical(change_y)]))
}
rm(pop)
rm(A)
rm(B)
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
change_x <- sample(x = c(0,1),
size = sum(current_pop$mutate == 1),
replace = T)
change_y <- -1*(change_x - 1)
# Determine the amount each changes by.
# normal distribution mean 0, std = 0.2
change_pc <- rnorm(n = length(change_x), mean = 0, sd = 0.2)
change_pc
pop[as.logical(change_x),]$x
current_pop[as.logical(change_x),]
change_x
current_pop
current_pop[as.logical(change_x),]
change_x
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
change_x <- c(rep(0,pop_size),
sample(x = c(0,1),
size = sum(current_pop$mutate == 1),
replace = T))
change_x
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
change_x <- c(rep(-1,pop_size),
sample(x = c(0,1),
size = sum(current_pop$mutate == 1),
replace = T))
change_x
-1*(change_x - 1)
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
change_x <- c(rep(0,pop_size),
sample(x = c(0,1),
size = sum(current_pop$mutate == 1),
replace = T))
change_y <- -1*(change_x - 1)
change_y
change_y[1:pop_size] <- 0
change_y
change_x
# Determine the amount each changes by.
# normal distribution mean 0, std = 0.2
change_pc <- rnorm(n = length(change_x), mean = 0, sd = 0.2)
change_pc
# Apply changes to x and y
current_pop[as.logical(change_x),]$x <- (pop[as.logical(change_x),]$x
* (1 + change_pc[as.logical(change_x)]))
# Apply changes to x and y
current_pop[as.logical(change_x),]$x <- (current_pop[as.logical(change_x),]$x
* (1 + change_pc[as.logical(change_x)]))
current_pop
current_pop[as.logical(change_x),]
current_pop[as.logical(change_y),]
1 + change_pc[as.logical(change_x)]
1 + change_pc[as.logical(change_y)]
mutate <- function(current_pop, pop_size, mut_chance = 0.1){
# roll dice to determine whether each new born mutates
current_pop$mutate <- c(rep(0,pop_size),
sample(x = c(0,1),
size = nrow(current_pop[current_pop$gen == max(current_pop$gen),]),
replace = T,
prob = c(1-mut_chance, mut_chance)))
if (any(current_pop$mutate)){
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
change_x <- c(rep(0,pop_size),
sample(x = c(0,1),
size = sum(current_pop$mutate == 1),
replace = T))
change_y <- -1*(change_x - 1)
change_y[1:pop_size] <- 0
# Determine the amount each changes by.
# normal distribution mean 0, std = 0.2
change_pc <- rnorm(n = length(change_x), mean = 0, sd = 0.1)
# Apply changes to x and y
current_pop[as.logical(change_x),]$x <- (current_pop[as.logical(change_x),]$x
* (1 + change_pc[as.logical(change_x)]))
current_pop[as.logical(change_y),]$y <- (current_pop[as.logical(change_y),]$y
* (1 + change_pc[as.logical(change_y)]))
# recalculate fitness
current_pop <- calculateFitness(current_pop)
}
return(current_pop)
}
current_pop
source('preamble.R')
# Use Ackley function to demonstrate GA
# Plot the function
ack <- makeAckleyFunction(2)
# Plot the function with overlain seeded initial population
res <- 0.1
min_range <- -3
max_range <- 3
x_range <- seq(min_range, max_range, by = res)
y_range <- x_range
dat <- expand.grid(x = x_range,
y = y_range,
z = 0)
for (i in 1:nrow(dat)){
dat$z[i] <- ack(c(dat$x[i], dat$y[i]))
}
ggplot(data = dat, aes(x = x,
y = y,
z = z)) +
geom_contour_filled(bins = 20) +
labs(title = '2D Ackley function',
fill = 'Z')
################################################################################
# functions
createPop <- function(pop_size, min_range, max_range){
out <- data.frame('gen' = 1,
'id' = seq(1:20),
'x' = runif(20, min_range, max_range),
'y' = runif(20, min_range, max_range))
return(out)
}
calculateFitness <- function(pop){
for (i in 1:nrow(pop)){
pop$fit[i] <- ack(c(pop$x[i], pop$y[i]))
}
return(pop)
}
selectBreeders <- function(pop, pop_size, breed_prop){
# roulette wheel
#how many?
breed_num <- 2*round(pop_size*breed_prop/2,0)
weight <- (1/pop$fit)/sum(1/pop$fit)
selected <- sample(pop$id, size = breed_num, replace = F, prob = weight)
breeders <- rep(0,pop_size)
breeders[selected] <- 1
return(breeders)
}
reproduce <- function(current_pop, alpha = 0.66){
# filter to breeders
pop <- current_pop[current_pop$breeder == 1,]
# randomly order parents
parent_list <- sample(pop$id, size = nrow(pop), replace = F)
# split parents into two
parents1 <- pop[pop$id %in% parent_list[1:(length(parent_list)/2)],]
parents2 <- pop[pop$id %in% parent_list[(length(parent_list)/2 + 1):length(parent_list)],]
# generate new individuals by weighted average of parents
new_x1 <- alpha * parents1$x + (1 - alpha) * parents2$x
new_y1 <- alpha * parents1$y + (1 - alpha) * parents2$y
new_x2 <- alpha * parents2$x + (1 - alpha) * parents1$x
new_y2 <- alpha * parents2$y + (1 - alpha) * parents1$y
# Make df of newborns
new_born <- data.frame('gen' = current_pop$gen[1]+1,
'id' = seq(max(current_pop$id)+1, max(current_pop$id)+length(parent_list)),
'x' = c(new_x1, new_x2),
'y' = c(new_y1, new_y2),
'fit' = 0,
'breeder' = 0)
# add to current population
pop <- rbind(current_pop, new_born)
pop <- calculateFitness(pop)
return(pop)
}
mutate <- function(current_pop, pop_size, mut_chance = 0.1){
# roll dice to determine whether each new born mutates
current_pop$mutate <- c(rep(0,pop_size),
sample(x = c(0,1),
size = nrow(current_pop[current_pop$gen == max(current_pop$gen),]),
replace = T,
prob = c(1-mut_chance, mut_chance)))
if (any(current_pop$mutate)){
# for those that mutate, pick either x or y to mutate
# 0 = x, 1 = y
change_x <- c(rep(0,pop_size),
sample(x = c(0,1),
size = sum(current_pop$mutate == 1),
replace = T))
change_y <- -1*(change_x - 1)
change_y[1:pop_size] <- 0
# Determine the amount each changes by.
# normal distribution mean 0, std = 0.2
change_pc <- rnorm(n = length(change_x), mean = 0, sd = 0.1)
# Apply changes to x and y
current_pop[as.logical(change_x),]$x <- (current_pop[as.logical(change_x),]$x
* (1 + change_pc[as.logical(change_x)]))
current_pop[as.logical(change_y),]$y <- (current_pop[as.logical(change_y),]$y
* (1 + change_pc[as.logical(change_y)]))
# recalculate fitness
current_pop <- calculateFitness(current_pop)
}
return(current_pop)
}
# GA inputs
pop_size <- 20
breed_prop <- 0.3
# Initial population
pop <- createPop(pop_size, min_range, max_range)
# Calculate fitness
pop <- calculateFitness(pop)
# Split into total pop and current pop
total_pop <- pop
current_pop <- pop
rm(pop)
# Plot initial population on heatmap
ggplot() +
geom_contour_filled(data = dat,
aes(x = x,
y = y,
z = z),
bins = 20) +
geom_point(data = current_pop,
aes(x = x,
y = y),
shape = 2,
size = 5,
stroke = 2) +
labs(title = '2D Ackley function',
fill = 'Z')
# Highlight selected to breed
current_pop$breeder <- selectBreeders(pop = current_pop,
pop_size = pop_size,
breed_prop = breed_prop)
# Plot initial population on heatmap, with breeders highlighted
ggplot() +
geom_contour_filled(data = dat,
aes(x = x,
y = y,
z = z),
bins = 20) +
geom_point(data = current_pop,
aes(x = x,
y = y,
colour = as.factor(breeder)),
shape = 2,
size = 5,
stroke = 2) +
labs(title = '2D Ackley function',
fill = 'Z',
colour = 'Selected')
# Highlight reproduction
current_pop <- reproduce(current_pop = current_pop)
# Plot current population on heatmap, with new born highlighted
ggplot() +
geom_contour_filled(data = dat,
aes(x = x,
y = y,
z = z),
bins = 20) +
geom_point(data = current_pop,
aes(x = x,
y = y,
colour = as.factor(gen)),
shape = 2,
size = 5,
stroke = 2) +
labs(title = '2D Ackley function',
fill = 'Z',
colour = 'Generation')
current_pop
# Highlight Mutation
current_pop <- mutate(current_pop)
# Highlight Mutation
current_pop <- mutate(current_pop = current_pop,
pop_size = pop_size,
mut_chance = 0.1)
current_pop
